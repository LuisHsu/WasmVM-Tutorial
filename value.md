# 數值型別

### 位元 \(Bit\)

電腦是透過電來操作，而電路的狀態可以簡單的用 0 \(斷電\) 或 1 \(通電\) 來表示，因此一個表示 0 或 1 的單位我們稱為一個 **位元**

一筆資料裡最大的位元 \(Most Significant Bit\)，習慣上簡稱為 **MSB** ，最小的位元 \(Least Significant Bit\)，習慣上簡稱為 **LSB**

### 位元組 \(Byte\)

習慣上我們會把 8 個位元做為一組，當成一個單位，稱為 **位元組**

### 位元組順序 \(Byte order\)

當一筆資料用不只一個位元組來表示的時候，不同的位元組之間會有誰先誰後的順序問題。像是 1234 這個數字，習慣上我們會從左到右寫成 1234，不過有些中式寫法也可能從右到左寫，變成 4321。因此根據從比較大的位數 \(1\) 開始或從比較小的位數 \(4\) 開始的不同，可以分成以下兩種

* big-endian

  比較大的位元組 -&gt; 比較小的位元組，在日常生活中、網路，或是某些作業系統比較常使用

* little-endian

  比較小的位元組 -&gt; 比較大的位元組，在大部份的作業系統比較常使用

假設一個以16進位表示的整數 0x12ABCDEF, 在 big-endian 的系統會排列成 0x12ABCDEF，little-endian 的系統會排列成 0xEFCDAB12

**\* 注意一個 16 進位的數字只有 4 位元，所以一個位元組會有 2 個 16 進位的數字**

WebAssembly 的規範中一律採用 **little-endian** 排列方式

### 整數

我們生活中使用的整數是 10 進位整數，然而在電腦中是以 0 和 1 表示各種資料，所以使用 2 進位整數。一筆整數資料中可能會利用一個位元表示正負號，或是沒有正負號，因此分為 **有號整數** 和 **無號整數**

#### 無號整數

沒有表示正負號的位元，直接使用整數的二進位表示 $$0 \sim 2^{31} - 1$$ 之間的 **正整數**

#### 有號整數

有表示正負號的位元，習慣上會用 MSB 表示正負號，所以能表示$$-2^{31} \sim 2^{31}-1$$之間的整數

#### 1 補數 \(1's Complement\)

電腦上的減法是用"加負數"的方式實作，為了方便運算，在負數的部份我們可以把正數做位元反轉，像是 8 位元的 00000001 \(1\) 取負數之後就變成 11111110 \(-1\)，這種表示負數的方式稱為** 1 補數。**

以 8 位元的 1 - 2 為例，用 1 補數的運算會變成

00000001 \(1\) + 11111101 \(-2\) = 11111110 \(-1\)

很輕易的就用加法完成減法運算

##### 1 補數的缺點

1. 有 +0, -0 之分
   0 在數學上是沒有正負之分的，不過對 0 做反轉會得到一長串的 1，這個就稱之為 -0。-0 的出現讓運算時需要再判斷有沒有 -0 存在，增加了複雜度
2.  循環進位
   當兩數相加有超出範圍的進位時，需要把超出的進位再加回去，不然會發生錯誤，請看下面的例子
   11111110 \(-1\) + 00000010 \(2\) = ~~1~~00000000 \(0\) 這是錯誤的
   要把捨掉的 1 加回去答案才會變成 00000001 \(1\)



#### 2 補數 \(2's Complement\)



