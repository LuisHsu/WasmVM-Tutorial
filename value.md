# 數值型別

### 位元 \(Bit\)

電腦是透過電來操作，而電路的狀態可以簡單的用 0 \(斷電\) 或 1 \(通電\) 來表示，因此一個表示 0 或 1 的單位我們稱為一個 **位元**

一筆資料裡最大的位元 \(Most Significant Bit\)，習慣上簡稱為 **MSB** ，最小的位元 \(Least Significant Bit\)，習慣上簡稱為 **LSB**

### 位元組 \(Byte\)

習慣上我們會把 8 個位元做為一組，當成一個單位，稱為 **位元組**

### 位元組順序 \(Byte order\)

當一筆資料用不只一個位元組來表示的時候，不同的位元組之間會有誰先誰後的順序問題。像是 1234 這個數字，習慣上我們會從左到右寫成 1234，不過有些中式寫法也可能從右到左寫，變成 4321。因此根據從比較大的位數 \(1\) 開始或從比較小的位數 \(4\) 開始的不同，可以分成以下兩種

* big-endian

  比較大的位元組 -&gt; 比較小的位元組，在日常生活中、網路，或是某些作業系統比較常使用

* little-endian

  比較小的位元組 -&gt; 比較大的位元組，在大部份的作業系統比較常使用

假設一個以16進位表示的整數 0x12ABCDEF, 在 big-endian 的系統會排列成 0x12ABCDEF，little-endian 的系統會排列成 0xEFCDAB12

**\* 注意一個 16 進位的數字只有 4 位元，所以一個位元組會有 2 個 16 進位的數字**

WebAssembly 的規範中一律採用 **little-endian** 排列方式

### 整數 \(Integer\)

我們生活中使用的整數是 10 進位整數，然而在電腦中是以 0 和 1 表示各種資料，所以使用 2 進位整數。一筆整數資料中可能會利用一個位元表示正負號，或是沒有正負號，因此分為 **有號整數** 和 **無號整數**

#### 無號整數

沒有表示正負號的位元，直接使用整數的二進位表示 $$0 \sim 2^{31} - 1$$ 之間的 **正整數**

#### 有號整數

有表示正負號的位元，習慣上會用 MSB 表示正負號，所以能表示$$-2^{31} \sim 2^{31}-1$$之間的整數

##### 1 補數 \(1's Complement\)

電腦上的減法是用"加負數"的方式實作，為了方便運算，在負數的部份我們可以把正數做位元反轉，像是 8 位元的 00000001 \(1\) 取負數之後就變成 11111110 \(-1\)，這種表示負數的方式稱為** 1 補數。**

以 8 位元的 1 - 2 為例，用 1 補數的運算會變成

00000001 \(1\) + 11111101 \(-2\) = 11111110 \(-1\)

很輕易的就用加法完成減法運算

##### 1 補數的缺點

1. 有 +0, -0 之分
   0 在數學上是沒有正負之分的，不過對 0 做反轉會得到一長串的 1，這個就稱之為 -0。-0 的出現讓運算時需要再判斷有沒有 -0 存在，增加了複雜度
2. 需要循環進位
   當兩數相加有超出範圍的進位時，需要把超出的進位再加回去，不然會發生錯誤，請看下面的例子
   11111110 \(-1\) + 00000010 \(2\) = ~~1~~00000000 \(0\) 這是錯誤的
   要把捨掉的 1 加回去答案才會變成 00000001 \(1\)

##### 2 補數 \(2's Complement\)

1 補數存在負零和需要循環進位等等缺點，因此現今的電腦普遍採用的是** 2 補數**這種表示方式。

2 補數的負數算法是將位元反轉之後，再把結果加 1

例如 8 位元的 00000001 \(1\)，位元反轉變成 11111110，再加 1 成為 11111111 \(-1\)  
使用 2 補數可以避免負零的產生，因為 0 在位元反轉之後是 11111111，加 1 之後是 ~~1~~ 00000000，把進位捨去一樣是原本的 0。兩數相加之後如果有進位也只需要把多出來的進位捨去即可，沒有需要循環進位的問題

WebAssembly 的規範中一律採用 **2 補數** 作為有號整數的表示方法

### 浮點數 \(Floating point number\)

浮點數也就是小數，不像整數一樣直接用 2 進位，而是有特殊的表示方式。

#### 單精度浮點數 \(Single-precision\)

單精度浮點數有 32 位元，以 2 進位的小數科學記號表示



浮點數的位元分成以下3個區域

![](/images/float.png)

* 正負號
  0 表示正數，1表示負數
* 指數
* 有效數

#### 倍精度服點數 \(Double-precision\)



